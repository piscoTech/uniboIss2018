\input{preamble.tex}

\title{Ingegneria dei Sistemi Software M}
\date{A.A. 2017--2018}
\author{Marco Boschi, Marco Rossini}

\begin{document}

\maketitletoc

\section{Analisi dei requisiti}
Il robot DDR è un dispositivo in grado di muoversi in un ambiente attraverso comandi remoti per avanzare, indietreggiare o girare di \ang{90} a destra o sinistra oltre al comando di stop. L'ambiente in cui dovrà muoversi è una stanza quadrata che può essere sia fisica che virtuale. La stanza è dotata di due sonar: uno, detto \texttt{sonar1}, è posto in alto a sinistra e rivolto verso il basso, l'altro, detto \texttt{sonar2}, è posto in basso a destra rivolto verso sinistra.

Il robot dovrà muoversi da una posizione iniziale intercettata da \texttt{sonar1}, detta \texttt{start-point}, e muoversi lungo la stanza fino alla posizione finale, detta \texttt{end-point}, intercettata da \texttt{sonar2} mentre pulisce il pavimento, \textit{richiedendo quindi di passare sulla maggior superficie possibile del pavimento}.

Per \textit{sonar} si intende un dispositivo, reale o virtuale, che sfrutta una qualche tecnologia per individuare quando il robot passa davanti a questo.

Il robot è controllato attraverso un'interfaccia grafica, detta \texttt{console}, accessibile ad un utente umano autorizzato dall'inserimento di credenziali riconosciute dal sistema. L'attività di pulizia è innescata dall'invio del comando \texttt{START} da parte dell'utente autorizzato che controlla il robot. Ciò avviene mediante un qualunque dispositivo in grado di connettersi al robot.

Il robot lavora solo se la temperatura dell'ambiente non è superiore ad una soglia prefissata e se l'ora corrente è all'interno di un intervallo prefissato. Il robot è dotato di un sensore di temperatura e di un orologio per verificare queste condizioni.

Durante l'attività di pulizia, il robot deve far lampeggiare una lampada a led HUE, ovvero una lampadina, connessa alla rete, che può essere controllata in luminosità, accensione, spegnimento e colore attraverso API RESTful.

Durante l'attività di pulizia, il robot deve inoltre aver cura di evitare ostacoli fissi presenti nella stanza.

L'attività di pulizia deve terminare se:
\begin{itemize}
\item l'utente autorizzato invia il comando \texttt{STOP} dalla console;
\item la temperatura dell'ambiente supera la soglia prefissata;
\item l'ora corrente esce dall'intervallo prefissato;
\item il robot non riesce, in alcun modo, ad evitare un certo ostacolo;
\item il robot ha terminato l'attività di pulizia, ovvero raggiunge la posizione finale.
\end{itemize}

\section{Analisi del problema e scelte progettuali}
Analizzando i progetti realizzati e presentati a lezione, si ha già a disposizione la console, realizzata come un frontend server in tecnologia Node.js. Essa presenta l'autenticazione degli utenti attraverso una coppia username-password come credenziali di accesso ed i comandi per pilotare il robot nelle sue azioni di base. Possono essere aggiunti facilmente i pulsanti per inviare i comandi di \texttt{START} e \texttt{STOP}.

Il sistema che si deve realizzare è distribuito, pertanto è necessario individuare un sistema di comunicazione tra le parti, ossia il frontend, il robot, i sensori e i sonar. Ciò può essere individuato nello scambio di eventi supportato dall'infrastruttura MQTT già integrata all'interno della console che si ha a disposizione. 

Nella scelta di lavorare all'interno di un ambiente virtuale, si ha a disposizione il progetto ConfigurableThreejsApp, che offre l'ambiente virtuale, dotato dei sonar, ed il robot virtuale. Esso è accessibile attraverso un'interfaccia web e controllabile attraverso una socket TCP.

Per realizzare un primo prototipo del robot con la logica applicativa che controlla l'attività di pulizia ci si appoggia a un linguaggio che permette di scrivere modelli eseguibili per garantire una rapida prototipazione. Questo linguaggio viene individuato in QActor, che permette anche di integrarsi nativamente con un'infrastruttura a scambio di eventi via MQTT e lavorando su una base Java permette facilmente di avere accesso a delle API per gestire le socket.

Dato che il robot non comunica nativamente via eventi occorre realizzare un attore, con funzione di adapter, che intercetti i comandi di base inviati dalla console, o dalla logica applicativa durante la pulizia, per pilotare il robot e li traduca in un flusso di dati TCP che il robot possa comprendere. Questo adapter si occuperà anche di ricevere le segnalazioni dei sonar e tradurle in eventi affinché gli altri attori del sistema possano esserne a conoscenza.

Per gestire la logica applicativa si rende necessario un attore dedicato che riceva i comandi di \texttt{START} e \texttt{STOP} per controllare l'avvio e la terminazione dell'attività di pulizia, la gestisca e controlli che le condizioni specificate per operare siano soddisfatte.

Per ricevere informazioni su temperatura ambientale e ora corrente occorre realizzare due sensori, un termometro e un orologio, che possano inviare le rispettive informazioni. Poiché queste interessano solamente l'attività di pulizia automatica, possono essere intercettate solamente dall'attore che si occupa della logica applicativa e usarle per aggiornare lo stato interno e terminare, se è il caso, l'attività di pulizia.

Non avendo a disposizione una realizzazione, fisica o virtuale, in grado di interagire in qualche modo con il sistema per come lo si è individuato finora, si è scelto di realizzarli da zero come sensori virtuali direttamente integrati con l'infrastruttura MQTT. È stato realizzato anche un mock per la lampada HUE per poter testare il funzionamento del robot quando quella fisica non è accessibile. Questo mock interagisce direttamente con gli eventi di controllo scambiati via MQTT, ma per controllare quella fisica occorre realizzare un adapter che intercetti gli aventi e li traduca in opportune chiamate RESTful.

Per mantenere lo stato del sistema ci si può appoggiare al supporto nativo del Prolog da parte di QActor per modellare una base di conoscenza che tenga traccia di temperatura e ora corrente, se si sta facendo la pulizia e qualunque altra informazione utile come la soglia di temperatura e l'intervallo di tempo in cui si può lavorare.

\section{Log}

\subsection{1° settimana}
Ci siamo concentrati sull'analisi dei requisiti e del problema a livello generale per individuare le parti che abbiamo già a disposizione da progetti svolti a lezione. Queste parti sono state assemblate assieme a un mock per i dispositivi hardware (sensori e attuatori) richiesti per avere un primo prototipo funzionante, ma senza logica applicativa, del sistema.

\end{document}
