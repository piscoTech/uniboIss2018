// Model after the requirement analysis
System finalSys2018

Event usercmd		: usercmd(CMD)					// From web gui
Event sonar			: sonar(SONAR, X, DISTANCE)		// From (virtual) sonar
Event sonarDetect	: sonarDetect(X)					// From (virtual) robot sonar

Dispatch moveRobot	: usercmd(CMD)
Event ctrlAppl		: ctrlAppl(X)					// X = go | halt

Event ctrlEvent		: ctrlEvent(TARGET, PAYLOAD)
Event sensorEvent	: sensorEvent(ORIGIN, PAYLOAD)
Event lampEvent		: lampEvent(VERB, INFO)			// Feedback for controlling the real lamp

pubSubServer "tcp://localhost:1883"

Context ctxFinalSysAnalysis ip [host="localhost" port=8010]
EventHandler evh for usercmd -pubsub {
	forwardEvent robot -m moveRobot
};

QActor webguiexecutor context ctxFinalSysAnalysis -pubsub {
	Rules {
		tempThreshold(25).			// 25°C
		timeInterval(32400, 39600).	// 9:00:00 - 11:00:00
		sonarThreshold(5).
		
		model(thermometer, 20).	// 20°C
		model(clock, 36300). 	// 10:05:00
		model(blinker, off).
		
		validConditions :-
			model(thermometer, T), model(clock, H), tempThreshold(Tmax), timeInterval(Hmin, Hmax),
			eval(le, T, Tmax), eval(ge, H, Hmin), eval(le, H, Hmax).
			
		inFrontOfSonar :- sonarThreshold(Dmax),
			curSonarDistance(D), eval(le, D, Dmax).		
 		
		changedModelAction(thermometer, _) :- validConditions, !. 
		changedModelAction(thermometer, _) :- emitEvent(ctrlAppl, ctrlAppl(halt)).
		
		changedModelAction(clock, _) :- validConditions, !. 
		changedModelAction(clock, _) :- emitEvent(ctrlAppl, ctrlAppl(halt)).
					     
		changedModelAction(blinker, V) :- emitEvent(ctrlEvent, ctrlEvent(blinker, V)).
	}
	
	Plan init normal [
		demo consult('./resourceModel.pl');
		println("Application ready")
	]
	switchTo listen
	
	Plan listen [] transition stopAfter 3600000
		whenEvent ctrlAppl -> startLogic,
		whenEvent sensorEvent -> handleSensor
	finally repeatPlan
		
	Plan startLogic resumeLastPlan [
		[!? validConditions] {
			onEvent ctrlAppl : ctrlAppl(go) -> addRule shouldStart
		} else
			println("Sensors conditions invalid, cannot clean")
	]
	switchTo [?? shouldStart] checkInitialPosition
	
	Plan checkInitialPosition resumeLastPlan [
		println("Sensors conditions are valid, checking initial position...")
	]
	transition
		whenTime 1000 -> listen,
		whenEvent sonar -> checkInitialSonarDistance
		
	Plan checkInitialSonarDistance resumeLastPlan [
		removeRule curSonarDistance(D);
		onEvent sonar : sonar(sonar1, player, D) -> addRule curSonarDistance(D)
	]
	switchTo [!? inFrontOfSonar] clean
			
	Plan clean [
		println("Application started...");
		demo changeModelItem(blinker, on)
	]
	switchTo cleanRotate
	
	Plan cleanMove [
		forward robot -m moveRobot : usercmd( robotgui(w(X)) )
	]
	transition
		whenTime 1000 -> cleanRotate,
		whenEvent sensorEvent -> handleSensor,
		whenEvent ctrlAppl -> cleanStop
	finally repeatPlan
	
	Plan cleanRotate [
		forward robot -m moveRobot : usercmd( robotgui(h(X)) );
		forward robot -m moveRobot : usercmd( robotgui(d(X)) )
	]
	transition
		whenTime 1000 -> cleanMove,
		whenEvent sensorEvent -> handleSensor,
		whenEvent ctrlAppl -> cleanStop
	finally repeatPlan
	
	Plan cleanStop [
		demo changeModelItem(blinker, off);
		forward robot -m moveRobot : usercmd( robotgui(h(X)) );
		println("Application stopped.")
	]
	switchTo listen
	
	Plan handleSensor resumeLastPlan [
		// O = thermometer	=> P = real number representing the current temperature
		// O = clock 		=> P = positive integer representing the number of seconds from midnight (00:00:00 = 0, 23:59:59 = 86399, 10:05:06 = 10*3600 + 5*60 + 6)
		onEvent sensorEvent : sensorEvent(O, P) -> demo changeModelItem(O, P)
	]
	switchTo [not !? validConditions] cleanStop
}

QActor blinker context ctxFinalSysAnalysis -pubsub {
	Plan init normal [
		println("Blinker ready...")
	]
	switchTo listen
	
	Plan listen [] transition stopAfter 3600000
		whenEvent ctrlEvent -> checkStart
	finally repeatPlan	
	
	Plan checkStart resumeLastPlan [
		onEvent ctrlEvent : ctrlEvent(blinker, on) -> addRule shouldBlink
	]
	switchTo [?? shouldBlink] blinkOn
	
	Plan blinkOn [
		emit ctrlEvent : ctrlEvent(hueLamp, on)
	] transition
		whenTime 500 -> blinkOff,
		whenEvent ctrlEvent -> checkEnd
	finally repeatPlan
		
	Plan blinkOff [
		emit ctrlEvent : ctrlEvent(hueLamp, off)
	] transition
		whenTime 500 -> blinkOn,
		whenEvent ctrlEvent -> checkEnd
	finally repeatPlan
		
	Plan checkEnd resumeLastPlan [
		onEvent ctrlEvent : ctrlEvent(blinker, off) -> addRule shouldStop
	]
	switchTo [?? shouldStop] blinkStop
	
	Plan blinkStop [
		emit ctrlEvent : ctrlEvent(hueLamp, off)
	]
	switchTo listen
}

QActor robot context ctxFinalSysAnalysis -pubsub {
	Plan init normal [
		println("Robot started");
		javaRun it.unibo.robot.pfrs.mbotConnTcp.initClientConn()
	]
	switchTo listen
	
	Plan listen [] transition stopAfter 3600000
		whenMsg moveRobot -> execMove
	finally repeatPlan
		
	Plan execMove resumeLastPlan [
		printCurrentMessage;
		onMsg moveRobot : usercmd( robotgui(h(X)) ) -> javaRun it.unibo.robot.pfrs.mbotConnTcp.mbotStop();
		onMsg moveRobot : usercmd( robotgui(w(X)) ) -> javaRun it.unibo.robot.pfrs.mbotConnTcp.mbotForward();
		onMsg moveRobot : usercmd( robotgui(s(X)) ) -> javaRun it.unibo.robot.pfrs.mbotConnTcp.mbotBackward();
		onMsg moveRobot : usercmd( robotgui(a(X)) ) -> javaRun it.unibo.robot.pfrs.mbotConnTcp.mbotLeft();
		onMsg moveRobot : usercmd( robotgui(d(X)) ) -> javaRun it.unibo.robot.pfrs.mbotConnTcp.mbotRight();
		onMsg moveRobot : usercmd( robotgui(x(X)) ) -> emit ctrlAppl : ctrlAppl(X)
	]
}

QActor lampadapter context ctxFinalSysAnalysis -pubsub {
	Plan init normal [
		println("Lamp Adapter started");
		javaRun it.unibo.frontend.hueClient.setQaCtx("lampEvent")
	]
	switchTo listen
	
	Plan listen [] transition stopAfter 3600000
		whenEvent ctrlEvent -> ctrlLamp
	finally repeatPlan
	
	Plan ctrlLamp resumeLastPlan [
		printCurrentEvent;
		onEvent ctrlEvent : ctrlEvent(hueLamp,off)
			-> javaRun it.unibo.frontend.hueClient.sendPut("{'on':false}", "lights/2/state");
		onEvent ctrlEvent : ctrlEvent(hueLamp,on)
			-> javaRun it.unibo.frontend.hueClient.sendPut("{'on':true, 'bri':167}", "lights/2/state")
	]
}
